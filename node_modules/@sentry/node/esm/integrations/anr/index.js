import { _optionalChain, _optionalChainDelete } from '@sentry/utils';
import { URL } from 'url';
import { getCurrentScope } from '@sentry/core';
import { logger, dynamicRequire } from '@sentry/utils';
import { NODE_VERSION } from '../../nodeVersion.js';
import { base64WorkerScript } from './worker-script.js';

const DEFAULT_INTERVAL = 50;
const DEFAULT_HANG_THRESHOLD = 5000;

function log(message, ...args) {
  logger.log(`[ANR] ${message}`, ...args);
}

/**
 * We need to use dynamicRequire because worker_threads is not available in node < v12 and webpack error will when
 * targeting those versions
 */
function getWorkerThreads() {
  return dynamicRequire(module, 'worker_threads');
}

/**
 * Gets contexts by calling all event processors. This relies on being called after all integrations are setup
 */
async function getContexts(client) {
  let event = { message: 'ANR' };
  const eventHint = {};

  for (const processor of client.getEventProcessors()) {
    if (event === null) break;
    event = await processor(event, eventHint);
  }

  return _optionalChain([event, 'optionalAccess', _2 => _2.contexts]) || {};
}

/**
 * Starts a thread to detect App Not Responding (ANR) events
 */
class Anr  {
   __init() {this.name = 'Anr';}

   constructor(  _options = {}) {this._options = _options;Anr.prototype.__init.call(this);}

  /** @inheritdoc */
   setupOnce() {
    // Do nothing
  }

  /** @inheritdoc */
   setup(client) {
    if ((NODE_VERSION.major || 0) < 16) {
      throw new Error('ANR detection requires Node 16 or later');
    }

    // setImmediate is used to ensure that all other integrations have been setup
    setImmediate(() => this._startWorker(client));
  }

  /**
   * Starts the ANR worker thread
   */
   async _startWorker(client) {
    const contexts = await getContexts(client);
    const dsn = client.getDsn();

    if (!dsn) {
      return;
    }

    // These will not be accurate if sent later from the worker thread
     _optionalChainDelete([contexts, 'access', _3 => _3.app, 'optionalAccess', _4 => delete _4.app_memory]);
     _optionalChainDelete([contexts, 'access', _5 => _5.device, 'optionalAccess', _6 => delete _6.free_memory]);

    const initOptions = client.getOptions();

    const sdkMetadata = client.getSdkMetadata() || {};
    if (sdkMetadata.sdk) {
      sdkMetadata.sdk.integrations = initOptions.integrations.map(i => i.name);
    }

    const options = {
      debug: logger.isEnabled(),
      dsn,
      environment: initOptions.environment || 'production',
      release: initOptions.release,
      dist: initOptions.dist,
      sdkMetadata,
      pollInterval: this._options.pollInterval || DEFAULT_INTERVAL,
      anrThreshold: this._options.anrThreshold || DEFAULT_HANG_THRESHOLD,
      captureStackTrace: !!this._options.captureStackTrace,
      contexts,
    };

    if (options.captureStackTrace) {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const inspector = require('inspector');
      inspector.open(0);
    }

    const { Worker } = getWorkerThreads();

    const worker = new Worker(new URL(`data:application/javascript;base64,${base64WorkerScript}`), {
      workerData: options,
    });
    // Ensure this thread can't block app exit
    worker.unref();

    const timer = setInterval(() => {
      try {
        const currentSession = getCurrentScope().getSession();
        // We need to copy the session object and remove the toJSON method so it can be sent to the worker
        // serialized without making it a SerializedSession
        const session = currentSession ? { ...currentSession, toJSON: undefined } : undefined;
        // message the worker to tell it the main event loop is still running
        worker.postMessage({ session });
      } catch (_) {
        //
      }
    }, options.pollInterval);

    worker.on('message', (msg) => {
      if (msg === 'session-ended') {
        log('ANR event sent from ANR worker. Clearing session in this thread.');
        getCurrentScope().setSession(undefined);
      }
    });

    worker.once('error', (err) => {
      clearInterval(timer);
      log('ANR worker error', err);
    });

    worker.once('exit', (code) => {
      clearInterval(timer);
      log('ANR worker exit', code);
    });
  }
}

export { Anr };
//# sourceMappingURL=index.js.map
